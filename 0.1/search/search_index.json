{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gustave: structural integrity library for video games","text":"<p>Gustave is a C++ library providing static structural analysis for sandbox construction games. Concretely, Gustave analyses how a player-made structure supports (or not) its own weight.</p> <p></p> <p>This library has the double goal of being fun and educational:</p> <ul> <li>Fun: many games (city-builders, factory simulation, space/flight simulator, bridge builders, ...) base their core gameplay loop on finding solutions to complex realistic problems. A few construction games have already successfully implemented such loops using structural integrity.</li> <li>Educational: Gustave certainly doesn't replace a civil engineering degree, but is made in the hope that it will teach a few notions in physics, strength of materials, or architecture.</li> </ul> <p>To do so, Gustave uses a more realistic model than commonly used in the gaming industry. It is simply based on Newton's first law of motion: a block stays at rest only if the sum of forces exerted on it is zero. This library finds a force distribution that satisfies Newton's equations. These forces causes compression/shear/tensile stresses on each block. Each block has its own maximum nominal stress: if they are exceeded, the structure is not stable.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Compression/shear/tensile model: this offer both a touch of realism and interesting game design opportunities (the right material for the right situation).</li> <li>Optimized force distributions: Gustave tends to spread loads across multiple supports when possible, and prefers transferring force through stronger blocks.</li> <li>Horizontal/hanging construction support: it is possible to check the stability of a structure built on the side of a cliff, or from the ceiling of a cave. Gustave is not limited to building vertically from the ground</li> <li>3D physics</li> <li>Multi-level API:<ul> <li>World (cube grid only): just insert/remove blocks in a world. Gustave will automatically group them into independent structures, compute force distributions, and evaluate stresses.</li> <li>Solver (any block shape/position): Gustave generates a force distribution for a given structure.</li> </ul> </li> <li>Compile-time dimensional analysis (optional): Gustave uses C++ metaprogramming to enforce dimensional correctness at the API level and in its implementation. Adding a position vector with a force vector, or assigning a mass to a length, will generate compiler errors.</li> <li>Highly customizable library: template parameters allows to use float/double, another 3d-vector implementation, or another unit/dimension library.</li> <li>Performance &amp; scale: Gustave is currently able to evaluate a structure of 8,000 blocks in less than a second on a PC from 2012. This should already be sufficient for some video games, and there is still a lot of room for optimisation in future releases.</li> </ul>"},{"location":"#what-gustave-isnt","title":"What Gustave isn't","text":"<ul> <li>NO real-time simulation of failing structures: Gustave only perform static analysis. If you want a building collapsing in real time, use a conventional physics engine with rigid bodies.</li> <li>NO real life engineering: Gustave's model is absolutely not realistic enough to be used in actual civil engineering.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Gustave is a header-only library that just requires a C++20 compiler and standard library. The currently tested platforms are:</p> <ul> <li>gcc 13.1 (Linux, libstdc++)</li> <li>clang 17.0 (Linux, libc++)</li> <li>MSVC 19.44.35207 (Windows, Microsoft STL) (Visual Studio 2022)</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>This section explains the recommended ways to include the Gustave library into your project.</p> <p>Make sure your project is built with C++20 (or later) enabled.</p>"},{"location":"install/#conan","title":"Conan","text":""},{"location":"install/#conan-center-soontm","title":"Conan center (SOON\u2122)","text":"<p>Official releases of Gustave will be available on the Conan center.</p> <p>Add the gustave dependency in your project's conanfile.txt: <pre><code>[requires]\ngustave/0.1.0\n</code></pre></p> <p>Usage in your project's CMakeLists.txt: <pre><code>find_package(Gustave CONFIG REQUIRED Distrib-Std)\n\nadd_executable(your-binary\n    \"main.cpp\"\n)\ntarget_link_libraries(your-binary PRIVATE Gustave::Distrib-Std)\n</code></pre></p>"},{"location":"install/#from-source","title":"From source","text":"<p>The source tree has a valid conanfile that can be used to create the package locally on your machine.</p> <pre><code>git clone https://github.com/vsaulue/Gustave.git\nconan create ./Gustave -s:h build_type=Release -c tools.build:skip_test=True --build=missing\n</code></pre> <p>This package can then be consumed normally by your other local Conan projects.</p>"},{"location":"install/#vcpkg","title":"Vcpkg","text":""},{"location":"install/#official-registry-soontm","title":"Official registry (SOON\u2122)","text":""},{"location":"install/#from-source_1","title":"From source","text":"<p>Gustave's source tree has a vcpkg overlay that can be used by your projects locally.</p> <p>Note: if you're using Visual Studio, use a standalone installation of vcpkg (the one shipped with the IDE seems to have issues with overlays).</p> <ol> <li> <p>Clone Gustave somewhere on your machine (and optionally, checkout a specific version):</p> <pre><code>git clone https://github.com/vsaulue/Gustave.git /home/user123/somewhere/Gustave\n</code></pre> </li> <li> <p>Add an overlay port in the vcpkg-configuration.json file of your project, to <code>packaging/vcpkg/overlay</code> inside Gustave. Example:</p> <pre><code>{\n    \"default-registry\": {\n        \"kind\": \"git\",\n        \"baseline\": \"1a21d756f26d6b974cf52544b291bcdc65de6f4c\",\n        \"repository\": \"https://github.com/microsoft/vcpkg\"\n    },\n    \"overlay-ports\": [\n        \"/home/user123/somewhere/Gustave/packaging/vcpkg/overlay\"\n    ]\n}\n</code></pre> </li> <li> <p>Add a dependency to Gustave in the vcpkg.json of your project:</p> <pre><code>{\n    \"dependencies\": [\n        \"gustave\"\n    ]\n}\n</code></pre> </li> </ol>"},{"location":"install/#cmake","title":"CMake","text":"<p>The release builds includes proper CMake packaging files in the <code>cmake/</code> subfolder. To use them:</p> <ol> <li>Download a <code>gustave-release.zip</code> file from the Github releases.</li> <li>Unzip it somewhere on your machine.</li> <li>Edit your project's <code>CMakeLists.txt</code> as follows:     <pre><code>find_package(Gustave CONFIG REQUIRED Distrib-Std)\n\nadd_executable(your-binary\n    \"main.cpp\"\n)\ntarget_link_libraries(your-binary PRIVATE Gustave::Distrib-Std)\n</code></pre></li> <li>When configuring your project, add <code>-D Gustave_DIR=/path/to/unzipped/gustave-release/cmake</code> to your project's command line (note the <code>cmake</code> subfolder).</li> </ol>"},{"location":"install/#other","title":"Other","text":"<p>Gustave is currently a header-only library. The release builds package all headers in a single folder for easy integration with other build systems:</p> <ol> <li>Download a <code>gustave-release.zip</code> file from the Github releases.</li> <li>Unzip it somewhere on your machine.</li> <li>Add the subfolder <code>distrib-std/include</code> of the unzipped <code>gustave-release</code> as a header directory into your build.</li> </ol> <p>For example, to compile directly with <code>gcc</code>'s command line: <pre><code>g++ -std=c++20 -I /path/to/unzipped/gustave-release/distrib-std/include my-program.cpp -o my-program\n</code></pre></p>"},{"location":"lexicon/","title":"Terminology","text":"<p>This page describes a few terms used in Gustave's documentation and API.</p>"},{"location":"lexicon/#block","title":"Block","text":"<p>A block is the basic construction unit of anything. This could be a piece of floor, wall, pillar, ceiling...</p> <ul> <li>Each block has a weight.</li> <li>Each block can be designated as a foundation. A foundation is a block that won't move regardless of the force exerted on it by other block (e.g. they are solidly anchored to the ground or a cliff's side).</li> </ul> <p>In the high-level World API, the block has its own maximum compression/tensile/shear pressure values. These values have two roles:</p> <ul> <li>they are used to determine if the block (and its structure) is stable.</li> <li>they are used by the solver to generate a closer to optimal force distribution. For example, Gustave will try to avoid causing compression stress on a block with low compression strength.</li> </ul>"},{"location":"lexicon/#links-and-contacts","title":"Links and contacts","text":"<p>A link describes how two blocks can transfer a force between each other. A link is symmetrical: the link from block <code>A</code> to <code>B</code> is also a link from block <code>B</code> to <code>A</code>.</p> <p>The two blocks of a link must satisfy the following conditions:</p> <ul> <li>they are distincts (it is not possible to link a block with itself)</li> <li>at least one block must not be a foundation. In Gustave, two foundations never transfer forces directly between each other.</li> </ul> <p>Each link between <code>A</code> and <code>B</code> describes two opposite contacts:</p> <ul> <li>a contact on the surface of <code>A</code> (from <code>B</code>).</li> <li>a contact on the surface of <code>B</code> (from <code>A</code>).</li> </ul>"},{"location":"lexicon/#structure","title":"Structure","text":"<p>A structure is a set of blocks, and links between these blocks. It is the input problem of a solver.</p> <p>Structures should be:</p> <ul> <li>complete: if a structure contains a non-foundation block, it should also contains all blocks linked to it.</li> <li>independent: two different structures should not share a non-foundation block. However they might share foundations.</li> <li>minimal: if a structure contains two non-foundation blocks, they are (possibly indirectly) linked together by a chain of non-foundation blocks.</li> </ul> <p>Complete, independent structures are a requirement for Gustave's force distributions to have any logical sense.</p> <p>Using only minimal structures is strongly advised for performance:</p> <ul> <li>solving a big structure is slower than splitting it into independent structures and solving those separately. The resulting force distributions are the same.</li> <li>if a single structure is updated (e.g. by adding/removing blocks), only this structure needs to be solved again. The solution of any independent structure remains valid.</li> </ul>"},{"location":"lexicon/#force-distribution","title":"Force distribution","text":"<p>The goal of a force distribution is to assign a force vector to each contact in a structure. This represents the force transfer between each block of a structure.</p> <p>In Gustave, they respect the following conventions:</p> <ul> <li>for the contact on the surface of <code>A</code> (from <code>B</code>), this vector represents the force exerted on <code>A</code> by <code>B</code>.</li> <li>Opposite contacts follow Newton's 3rd law of motion: they have opposite force vectors.</li> </ul>"},{"location":"lexicon/#solver","title":"Solver","text":"<p>A solver finds a force distribution for a given structure that satisfies equilibrium conditions:</p> <ul> <li>Non-foundation blocks: the net force must be zero (within a margin of error), following Newton's 1st law of motion.</li> <li>Foundation blocks: no restriction on the net force.</li> </ul> <p>The goal of a solver is to transfer the weight of all non-foundation blocks in a structure to its foundation blocks.</p> <p>There is currently a single solver in Gustave, the <code>F1Solver</code> (Force 1):</p> <ul> <li>It generates force vectors in one dimension (colinear to the gravitational acceleration vector), hence the name.</li> <li>No restriction on block size, position, or contact area geometry.</li> <li>By far the biggest performance bottleneck in Gustave, and will likely remain that way (even if there is still a lot of room for optimisation left).</li> </ul>"},{"location":"lexicon/#world","title":"World","text":"<p>The world is the higher API level of Gustave. A user can simply place/remove blocks into it, and the world will:</p> <ul> <li>generate links between adjacent blocks</li> <li>regroup them into minimal, independent structures</li> <li>pass them to a solver to generate equilibrium force distributions, evaluate stresses, and checks if any block is subjected to stresses above their maximum compression/tensile/shear pressure values.</li> </ul> <p>The World API is currently limited to cuboid grids:</p> <ul> <li>all blocks are cuboid of the same dimensions</li> <li>they must be aligned to the global axes</li> </ul>"},{"location":"overview/","title":"Gustave Overview","text":"<p>This section will illustrate with concrete examples this library's key features: how it distributes forces inside a structure, and how it evaluates block stresses (and failing structures).</p> <p>A structure can have multiple valid force distributions. Gustave generates a distribution that is a compromise between multiple criteria:</p> <ul> <li>runtime performance</li> <li>minimizing block stress, and avoiding failing structures</li> <li>automatic load balancing between supports</li> <li>being intuitive to play with</li> <li>enabling interesting problem</li> </ul>"},{"location":"overview/#1-simple-tower","title":"1. Simple tower","text":"<p>The first example is a simple tower: a 1-wide column of blocks. Here there is only a single correct force distribution: any block in the stack receives the weight of all the blocks above it.</p> <p>Gustave's internal visualisation tool provides mainly two ways to display forces/stresses. You're free to use similar visualisations for your project, or to implement your own.</p>"},{"location":"overview/#contact-stress","title":"Contact stress","text":"<p>In the next image:</p> <ul> <li>block color represents the block \"type\". It can represent a specific combinaison of material (steel, wood, concrete), mass, layout within the block (full, tube, truss)...</li> <li>contact arrows:<ul> <li>the length represents the amount of force transferred. As the legend shows, it is measured in Newton. Gustave tries to use real physics units when relevant.</li> <li>the color represents the stress ratio: the ratio between the force transferred and the maximum force allowed by the blocks. Between green and orange, the force/stress is within the block's specifications. Between red and black, one block is failing.</li> </ul> </li> </ul> <p></p>"},{"location":"overview/#block-heat","title":"Block heat","text":"<p>In this image, the block's color represents its stress ratio: the maximum stress ratio of all its links/contacts. Colors from green to orange means the block is subjected to stresses it can withstand. Red to black means that the block is failing.</p> <p></p>"},{"location":"overview/#2-thicker-tower","title":"2. Thicker tower","text":"<p>This example shows that with Gustave's load balancing, it is possible to reach a higher height (or bridge a longer span) by making a pillar thicker at the base. Using a lighter or stronger material is not the only solution !</p> <p>This also illustrates that fixing a structure in Gustave can be made extremely beginner friendly: just use a simple color code to display which blocks are failing (example: red). A structure can usually be fixed by reinforcing the structure around the red blocks/contacts. No need to know what a Newton is.</p> <p></p>"},{"location":"overview/#3-materials-bridges","title":"3. Materials: bridges","text":"<p>This example shows how using materials with different compressive/shear/tensile strengths impacts how Gustave transfers weight in a bridge:</p> <ul> <li>Bridge 1: high compression strength blocks only. These blocks are good at transferring weight downwards, so Gustave transfers most of the bridge's weight to the pillars.</li> <li>Bridge 2: high shear strength blocks only. In Gustave, these blocks are good at transferring weight horizontally (a huge oversimplification from reality), so the library transfers most of the bridge's weight through the deck to the abutments.</li> <li>Bridge 3: high compression strength for pillars, high shear strength for the deck. It has no block nearing failure (orange color), contrary to the 2 other bridges.</li> </ul> <p>With the compression/shear/tensile model, whether a material is better than another is situational. The right material for the right problem can become a central game mechanic with Gustave.</p> <p></p>"},{"location":"overview/#4-materials-columns","title":"4. Materials: columns","text":"<p>First, this example shows that Gustave can transfer weight to higher blocks. Concretely, it is possible to build structures hanging from a surface of foundations (example: a cave ceiling).</p> <p>Second, it demonstrates how changing compression/shear/tensile strength of blocks influences a structure's force repartition. Each column can transfer its weight either to the floor or the ceiling.</p> <ul> <li>Left column (high compression strength): most weight is transferred to the ground</li> <li>Middle column (compression = tensile): the weight is equally split between the ceiling and the ground</li> <li>Right column (high tensile strength): most weight is transferred to the ceiling</li> </ul> <p>This repartition is a better solution than always evenly splitting between the floor and the ceiling: it reduces the overall stress of the blocks. It is not optimal: it would have been possible in this example to have no failing blocks by transferring forces differently.</p> <p></p>"},{"location":"overview/#5-block-mass-columns","title":"5. Block mass: columns","text":"<p>This example mixes blocks with different mass and strength in order to build the higher columns. Two block types are available: heavy and light. A light block has half the weight of a heavy block, and half its strength.</p> <p>The result shouldn't be surprising: a column built with a strong material at the base, and a light material at the top, can reach a higher height without failing.</p> <p></p>"},{"location":"overview/#6-eiffel-tower-300-blocks","title":"6. Eiffel tower (300 blocks)","text":"<p>This example was the library's first benchmark, with more than 300 blocks and 450 links. It can now be generated nearly instantly (&lt;20ms) on all tested compiler &amp; standard libraries.</p> <p></p>"},{"location":"overview/#7-dna-helix-8500-blocks","title":"7. DNA Helix (8500 blocks)","text":"<p>This example is the library's current benchmark, containing more than 8500 blocks and 15800 links. It was generated in less than 1 second on an Intel i5 3570k (from 2012) using gcc 13. This time includes parsing the input blocks as JSON and writing the output SVG file.</p> <p>Here the structure is a giant DNA helix made of concrete, where the foundations are on the left side. This extremely weird balcony has been chosen because it is in theory a bad scenario for Gustave's performance.</p> <p>About the results: concrete has a much higher compression strength than tensile strength. The structure has to transfer the weight from right to left.</p> <ul> <li>The bottom-right to top-left diagonals are subjected to tension &amp; shear stress: they fail early.</li> <li>The top-right to bottom-left diagonals are subjected to compression &amp; shear stress: they transfer more force without failing.</li> </ul> <p>Note</p> <p>You can click on images to zoom-in.</p> <p></p> <p></p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This section provides a few examples to learn how to use Gustave. Make sure you follow the install guide first.</p> <ol> <li>Getting started: selecting a library configuration, and getting started with basic maths.</li> <li>Solver API: using the low-level API of Gustave.</li> <li>World API: using the high-level API of Gustave.</li> </ol>"},{"location":"tutorials/01-getting-started/","title":"1. Getting started","text":"<p>If not done yet, please read the install guide to download Gustave and link it to your project.</p> <p>Gustave is a customisable library. Most of its classes takes a library configuration template parameter that enables using others:</p> <ul> <li>3d math implementations (ex: 3d vectors)</li> <li>units/dimensional analysis libraries (ex: using imperial units, or just not using any dimensional analysis)</li> <li>floating-point precision (float or double)</li> </ul> <p>The Gustave's core library with a configuration is called a distribution. You can eventually make your own, but to get started, you can use one of the 2 standard distribution.</p>"},{"location":"tutorials/01-getting-started/#distribution-stdstrictunit-vs-stdunitless","title":"Distribution: StdStrictUnit vs StdUnitless","text":"<p>Both these distributions just require a C++20 standard library to work. The difference is the unit/dimensional-analysis used:</p> <ul> <li><code>StdUnitless</code> doesn't do any dimensional analysis.</li> <li><code>StdStrictUnit</code> enforces dimensional analysis: any invalid operation (ex: assigning a velocity to a force), will produce atrocious compile-time errors that will rival the average Boost library. This is extremely valuable for Gustave's internal tests, but probably not worth the trouble for you.</li> </ul> <p>Conclusion: for your sanity, use <code>StdUnitless</code>.</p>"},{"location":"tutorials/01-getting-started/#precision-float-vs-double","title":"Precision: float vs double","text":"<p>Currently Gustave either only use <code>float</code> or <code>double</code>. With 32-bit precision, Gustave has stability issues and just won't work. Use 64-bit float (which is likely <code>double</code>, unless you have an exotic compiler).</p> <p>Conclusion: use <code>double</code> (64-bit floats).</p>"},{"location":"tutorials/01-getting-started/#getting-started-basic-maths","title":"Getting started: basic maths","text":"<p>This example will just show how to do basic maths with Gustave's <code>StdUnitless</code>: <pre><code>// One global header per distribution\n#include &lt;gustave/distribs/std/unitless/Gustave.hpp&gt;\n\nstatic void unitlessDemo() {\n    // Choosing a distribution, with double precision\n    using G = gustave::distribs::std::unitless::Gustave&lt;double&gt;;\n\n    std::cout &lt;&lt; \"Gustave 'Unitless' Demo\\n\\n\";\n    auto g = G::vector3(0, -9.8, 0);\n    auto mass = 1000.0;\n    auto weight = mass * g;\n    std::cout &lt;&lt; \"g = \" &lt;&lt; g &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"mass = \" &lt;&lt; mass &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"weight = mass * g = \" &lt;&lt; weight &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"wrong_operation = mass + g.y() = \" &lt;&lt; mass + g.y() &lt;&lt; '\\n';\n}\n</code></pre></p> <p>Expected output: <pre><code>Gustave 'Unitless' Demo\n\ng = { \"x\": 0, \"y\": -9.8, \"z\": 0 }\nmass = 1000\nweight = mass * g = { \"x\": 0, \"y\": -9800, \"z\": 0 }\nwrong_operation = mass + g.y() = 990.2\n</code></pre></p> <p>See the full code example, which also contains the equivalent demonstration for <code>StdStrictUnit</code>.</p>"},{"location":"tutorials/02-solver-api/","title":"2. Solver API","text":"<p>This section will describe Gustave's low-level API: Solvers.</p> <p>In this tutorial we'll aim at creating the following structure, and computing its force distribution:</p> <p></p> <p>Note</p> <p>In this tutorial, all quantities are interpreted in the metric system. This is not mandatory when using the <code>unitless</code> distribution. You can interpret them in another natural system of unit: if you choose to interpret 1 unit of length as an imperial <code>foot</code>, 1 unit of mass as an imperial <code>pound</code>, and 1 unit of time as a <code>second</code>, then 1 unit of force must be interpreted as a <code>pound.foot/second\u00b2</code>.</p>"},{"location":"tutorials/02-solver-api/#choosing-a-distribution","title":"Choosing a distribution","text":"<p>First, let's choose the <code>std::unitless</code> distribution with <code>double</code> precision, as explained in getting started:</p> <pre><code>// Choosing the Std Unitless distribution, with double precision\n#include &lt;gustave/distribs/std/unitless/Gustave.hpp&gt;\n\nusing G = gustave::distribs::std::unitless::Gustave&lt;double&gt;;\n</code></pre> <p>We'll also define some convenient type aliases:</p> <pre><code>using Structure = G::Solvers::Structure;\nusing Solver = G::Solvers::F1Solver;\n</code></pre>"},{"location":"tutorials/02-solver-api/#create-a-new-solver-structure","title":"Create a new solver structure","text":"<p>To create an empty <code>Structure</code>, just use its default constructor. We'll store ours in a std::shared_ptr, as it will be required later by the solver.</p> <pre><code>auto structure = std::make_shared&lt;Structure&gt;();\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;nodes().size() &lt;&lt; \" blocks\\n\";\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;links().size() &lt;&lt; \" links\\n\";\n</code></pre> <p>Expected output:</p> <pre><code>Structure of 0 blocks\nStructure of 0 links\n</code></pre>"},{"location":"tutorials/02-solver-api/#add-blocks-to-a-structure","title":"Add blocks to a structure","text":"<p>Use <code>Structure::addNode(...)</code>. This takes a <code>Structure::Node</code> object, whose constructor has 2 arguments:</p> <ul> <li>mass: the mass of the block (in kilogram)</li> <li>isFoundation: a boolean to indicate if this block is a foundation</li> </ul> <p>It returns a <code>NodeIndex</code>, a unique identifier of this block in the structure. These indices are generated sequentially (0,1,2,...).</p> <pre><code>auto const blockMass = 3'000.0; // kilogram\n//          xy\nauto const n00 = structure-&gt;addNode(Structure::Node{ blockMass, true });\nauto const n01 = structure-&gt;addNode(Structure::Node{ blockMass, false });\nauto const n02 = structure-&gt;addNode(Structure::Node{ blockMass, false });\nauto const n12 = structure-&gt;addNode(Structure::Node{ blockMass, false });\nauto const n22 = structure-&gt;addNode(Structure::Node{ blockMass, false });\nauto const n21 = structure-&gt;addNode(Structure::Node{ blockMass, false });\nauto const n20 = structure-&gt;addNode(Structure::Node{ blockMass, true });\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;nodes().size() &lt;&lt; \" blocks\\n\";\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;links().size() &lt;&lt; \" links\\n\";\n</code></pre> <p>Expected output:</p> <pre><code>Structure of 7 blocks\nStructure of 0 links\n</code></pre>"},{"location":"tutorials/02-solver-api/#add-links-to-a-structure","title":"Add links to a structure","text":"<p>Use <code>Structure::addLink(...)</code>. This takes a <code>Structure::Link</code> object, whose constructor has 4 arguments:</p> <ul> <li>localNodeId: the index of the first node</li> <li>otherNodeId: the index of the second node</li> <li>normal: the normal vector on the surface of localNode</li> <li>conductivity: a compression/shear/tensile quantity in <code>Newton/metre</code>. This is used by the solver to compute a force distribution: the higher the 3 components are, the more force will be transmitted through this link. It should be proportional to the maximum nominal force/pressure of the contact surface, and inversely proportional to the distance between the 2 nodes.</li> </ul> <p>It sequentially returns a <code>LinkIndex</code>, which uniquely identifies this link in the structure.</p> <pre><code>// { compression, shear, tensile } in Newton/metre\nauto const wallConductivity = G::Model::ConductivityStress{ 1'000'000.0, 500'000.0, 200'000.0 };\nauto const roofConductivity = G::Model::ConductivityStress{ 100'000.0, 500'000.0, 100'000.0 };\n\nauto const plusY = G::NormalizedVector3{ 0.0, 1.0, 0.0 };\nauto const plusX = G::NormalizedVector3{ 1.0, 0.0, 0.0 };\n\n// left wall\nauto const l00_01 = structure-&gt;addLink(Structure::Link{ n00, n01, plusY, wallConductivity });\nstructure-&gt;addLink(Structure::Link{ n01, n02, plusY, wallConductivity });\n// right wall\nauto const l20_21 = structure-&gt;addLink(Structure::Link{ n20, n21, plusY, wallConductivity });\nstructure-&gt;addLink(Structure::Link{ n21, n22, plusY, wallConductivity });\n// roof\nstructure-&gt;addLink(Structure::Link{ n02, n12, plusX, roofConductivity });\nstructure-&gt;addLink(Structure::Link{ n12, n22, plusX, roofConductivity });\n\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;nodes().size() &lt;&lt; \" blocks\\n\";\nstd::cout &lt;&lt; \"Structure of \" &lt;&lt; structure-&gt;links().size() &lt;&lt; \" links\\n\";\n</code></pre> <p>Here we stored 2 link indices for later use: <code>l00_01</code> (between foundation <code>n00</code> and block <code>n01</code>) and <code>l20_21</code> (between foundation <code>n20</code> and block <code>n21</code>).</p> <p>Expected output:</p> <pre><code>Structure of 7 blocks\nStructure of 6 links\n</code></pre> <p>Note: It is possible to mix calls to <code>Structure::addLink()</code> and <code>Structure::addNode()</code>. The only requirement is that when <code>addLink()</code> is called, the nodes in the new link are already declared.</p>"},{"location":"tutorials/02-solver-api/#configure-a-solver","title":"Configure a solver","text":"<p>For now the only solver available is the <code>F1Solver</code>, which generate force vectors that are always colinear with the gravity acceleration vector <code>g</code>.</p> <p>The two mandatory parameters for the solver are:</p> <ul> <li>g: the gravity acceleration vector in <code>metre/second\u00b2</code></li> <li>solverPrecision: the precision of the solver. The closer to 0 it is, the more accurate the solutions will be according to Newton's 1st law of motion (the net force of non-foundation blocks will be closer to 0).</li> </ul> <pre><code>[[nodiscard]]\nstatic Solver newSolver() {\n    auto const g = G::vector3(0.f, -10.f, 0.f); // gravity acceleration (metre/second\u00b2).\n    auto const solverPrecision = 0.01; // precision of the force balancer (here 1%).\n    return Solver{ Solver::Config{ g, solverPrecision } };\n}\n</code></pre> <pre><code>auto const solver = newSolver();\n\nstd::cout &lt;&lt; \"Solver gravity vector = \" &lt;&lt; solver.config().g() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Solver target max error = \" &lt;&lt; solver.config().targetMaxError() &lt;&lt; '\\n';\n</code></pre> <p>Expected output:</p> <pre><code>Solver gravity vector = { \"x\": 0, \"y\": -10, \"z\": 0 }\nSolver target max error = 0.01\n</code></pre>"},{"location":"tutorials/02-solver-api/#solve-a-structure","title":"Solve a structure","text":"<p>Simply use <code>F1Solver::run(structure)</code>. This returns a <code>SolverResult</code> object with a <code>isSolved()</code> method, indicating if a solution within the target <code>solverPrecision</code> was reached.</p> <pre><code>auto const solverResult = solver.run(structure);\nstd::cout &lt;&lt; \"solution.isSolved() = \" &lt;&lt; solverResult.isSolved() &lt;&lt; '\\n';\n</code></pre> <p>Expected output:</p> <pre><code>solution.isSolved() = 1\n</code></pre> <p>Warning</p> <p>Do not modify <code>structure</code> after passing it to the solver.</p>"},{"location":"tutorials/02-solver-api/#inspect-a-solutions-force-vectors","title":"Inspect a solution's force vectors","text":"<p>If a <code>SolverResult</code> object is solved, the <code>solution()</code> method returns a <code>Solution</code> object. This object provides convenient methods to inspect nodes, contacts, and forces.</p> <pre><code>auto const&amp; solution = solverResult.solution();\nstd::cout &lt;&lt; \"Force vector on block 00 by 01 = \" &lt;&lt; solution.contacts().at({l00_01, true}).forceVector() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Force vector on block 21 by 22 = \" &lt;&lt; solution.contacts().at({l20_21, false}).forceVector() &lt;&lt; '\\n';\n</code></pre> <p>A few comments on this block of code:</p> <ul> <li><code>solution.contacts()</code> returns a range to access any link/contact through a <code>ContactReference</code></li> <li><code>.at({l00_01, true})</code> gets us the contact from its <code>ContactIndex</code>. This contact index is made from the link index <code>l00_01</code>, and a <code>true</code> boolean indicating that we want the contact on the surface of <code>localNodeId</code>, so <code>n00</code> in this case</li> <li><code>.forceVector()</code> gets the force vector acting on the surface of <code>n00</code> from <code>n01</code>, transmitted through link <code>l00_01</code></li> </ul> <p>Possible output:</p> <pre><code>Force vector on block 00 by 01 = { \"x\": 0, \"y\": -75000, \"z\": 0 }\nForce vector on block 21 by 22 = { \"x\": -0, \"y\": 75000, \"z\": -0 }\n</code></pre> <p>Comments about this output:</p> <ul> <li>line 1: This is the force of contact index <code>{l00_01, true}</code>, so the force on the foundation <code>n00</code> from <code>n01</code>. Since the structure is symmetrical, we expect this force to be half the total weight of the structure. Total weight of the structure: <code>5 * blockMass * g = {0, -150'000, 0} Newton</code></li> <li>line 2: This is the force of contact index <code>{l20_21, false}</code>. The <code>false</code> inverses the <code>localNodeId</code> and <code>otherNodeId</code> of the contact: so this is the force on <code>n21</code> by the foundation <code>n20</code>. The foundation prevents <code>n21</code> from falling by pushing in the opposite direction of the gravity vector <code>g</code>. So the Y coordinate is positive.</li> </ul>"},{"location":"tutorials/03-world-api/","title":"3. World API","text":"<p>This section will describe Gustave's high-level API: Worlds.</p> <p>Its usage is simple: run a transaction to add/remove/replace blocks in a world. It will automatically group adjacent blocks into independent structures, and compute force distributions. It is then possible to inspect the stress ratio of each link, to test if each structure is stable (and if not, determine which link fails).</p> <p>For now, this API only support grids of cuboids (like a Minecraft world).</p> <p>Note</p> <p>The examples here will only use 2D constructions for easier visualisation, but 3D is supported.</p> <p>Note</p> <p>In this tutorial, all quantities are interpreted in the metric system. This is not mandatory when using the <code>unitless</code> distribution. You can interpret them in another natural system of unit: if you choose to interpret 1 unit of length as an imperial <code>foot</code>, 1 unit of mass as an imperial <code>pound</code>, and 1 unit of time as a <code>second</code>, then 1 unit of force must be interpreted as a <code>pound.foot/second\u00b2</code>.</p>"},{"location":"tutorials/03-world-api/01-creating-world/","title":"3.1. New world","text":"<p>This section explains how to create a new <code>SyncWorld</code> object.</p>"},{"location":"tutorials/03-world-api/01-creating-world/#choosing-a-distribution","title":"Choosing a distribution","text":"<p>First, let's choose the <code>std::unitless</code> distribution with <code>double</code> precision, as explained in getting started:</p> <pre><code>// Choosing the Std Unitless distribution, with double precision\n#include &lt;gustave/distribs/std/unitless/Gustave.hpp&gt;\n\nusing G = gustave::distribs::std::unitless::Gustave&lt;double&gt;;\n</code></pre> <p>We'll also define some type aliases:</p> <pre><code>using World = G::Worlds::SyncWorld;\nusing Solver = World::Solver;\n</code></pre>"},{"location":"tutorials/03-world-api/01-creating-world/#configuring-a-world","title":"Configuring a world","text":"<p>A <code>SyncWorld</code> can be created with these helper functions:</p> <pre><code>[[nodiscard]]\nstatic Solver newSolver() {\n    auto const g = G::vector3(0.f, -10.f, 0.f); // gravity acceleration (metre/second\u00b2).\n    auto const solverPrecision = 0.01; // precision of the force balancer (here 1%).\n    return Solver{ Solver::Config{ g, solverPrecision } };\n}\n\n[[nodiscard]]\nstatic World newWorld() {\n    auto blockSize = G::vector3(1.f, 1.f, 1.f); // block dimension (cube with 1m edge).\n    return World{ blockSize, newSolver() };\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>newSolver()</code>: configures the solver used by the world. See Solver API: configure a solver for more details.</li> <li><code>blockSize</code>: the dimensions of the blocks. Here each block is a <code>1 metre</code> wide cube.</li> </ul>"},{"location":"tutorials/03-world-api/01-creating-world/#usage","title":"Usage","text":"<p>Running this test code:</p> <pre><code>auto world = newWorld();\n\nstd::cout &lt;&lt; \"Tutorial: creating a new SyncWorld.\\n\\n\";\n\nstd::cout &lt;&lt; \"- number of blocks = \" &lt;&lt; world.blocks().size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"- number of structures = \" &lt;&lt; world.structures().size() &lt;&lt; '\\n';\n</code></pre> <p>Should give the following output:</p> <pre><code>Tutorial: creating a new SyncWorld.\n\n- number of blocks = 0\n- number of structures = 0\n</code></pre> <p><code>world.blocks()</code> and <code>world.structures()</code> are forward ranges which can be used to inspect the content of our world. As expected for an empty world, they have a size of 0.</p>"},{"location":"tutorials/03-world-api/02-world-blocks/","title":"3.2. Blocks","text":"<p>This sections explains how to inspect/add/modify/remove blocks in a <code>SyncWorld</code></p> <p>Note</p> <p>All world modifications are done through a <code>Transaction</code>. A transaction can do multiple insertions/modifications/deletions at once. For performance reasons, always try to group your modifications in as few transactions as possible.</p>"},{"location":"tutorials/03-world-api/02-world-blocks/#prerequisites","title":"Prerequisites","text":"<ul> <li>Selecting a Gustave configuration</li> <li>Creating an empty SyncWorld: we'll reuse the <code>newWorld()</code> function.</li> </ul> <pre><code>auto world = newWorld();\n</code></pre>"},{"location":"tutorials/03-world-api/02-world-blocks/#list-all-blocks","title":"List all blocks","text":"<p><code>world.blocks()</code> is a forward range. You can iterate over it using a range-based for loop:</p> <pre><code>// Utility function to list blocks.\nauto printBlocks = [&amp;world]() -&gt; void {\n    auto const&amp; blocks = world.blocks();\n    std::cout &lt;&lt; \"List of blocks (size = \" &lt;&lt; blocks.size() &lt;&lt; \"):\\n\";\n    for (auto const&amp; block : blocks) {\n        std::cout &lt;&lt; \"- \" &lt;&lt; block.index() &lt;&lt; \": mass = \" &lt;&lt; block.mass() &lt;&lt; \", isFoundation = \" &lt;&lt; block.isFoundation() &lt;&lt; '\\n';\n    }\n};\n</code></pre> <p><code>auto const&amp; block</code> is a C++ reference to a <code>BlockReference</code> object. Through this object, we can get any public property of the block:</p> <ul> <li>its mass: <code>block.mass()</code></li> <li>its maximum stress <code>block.maxPressureStress()</code></li> <li>if it's a foundation: <code>block.isFoundation()</code></li> <li>the structures it belongs to, its contacts, its current stress ratio...</li> </ul> <p>Note</p> <p>The iteration order is implementation defined. It will probably be different from the order of insertion, or the order of the block indices (like an unordered_map).</p>"},{"location":"tutorials/03-world-api/02-world-blocks/#insert-blocks","title":"Insert blocks","text":"<p>First, let's define a few constants for all the blocks in this tutorial:</p> <pre><code>auto const maxBlockStress = G::Model::PressureStress{\n    100'000.0, // compression (Pascal)\n    50'000.0,  // shear (Pascal)\n    20'000.0,  // tensile (Pascal)\n};\nauto const heavyMass = 10'000.0;  // kilogram\nauto const lightMass = 1'000.0;   // kilogram\n</code></pre> <p>Then we can create a simple tower in the <code>SyncWorld</code> with a <code>Transaction</code> like this:</p> <pre><code>{\n    // Create a new transaction\n    auto tr = World::Transaction{};\n    // Add a single foundation block at coordinates {0,0,0}\n    tr.addBlock({ { 0,0,0 }, maxBlockStress, heavyMass, true });\n    // Add 6 non-foundation blocks above the foundation\n    for (int i = 1; i &lt;= 6; ++i) {\n        tr.addBlock({ { 0,i,0 }, maxBlockStress, lightMass, false });\n    }\n    // Run the transaction\n    world.modify(tr);\n}\n</code></pre> <p>The key method is <code>World::Transaction::addBlock(BlockConstructionInfo const&amp;)</code>. The <code>BlockConstructionInfo</code> has a constructor taking 4 arguments:</p> <ul> <li><code>blockIndex</code>: the position of the block in the world.</li> <li><code>maxBlockStress</code>: the maximum constraints this block can withstand before failing.</li> <li><code>mass</code>: the mass of this block.</li> <li><code>isFoundation</code>: whether this block is a foundation.</li> </ul> <p>Possible output of <code>printBlocks()</code>:</p> <pre><code>List of blocks (size = 7):\n- { \"x\": 0, \"y\": 0, \"z\": 0}: mass = 10000, isFoundation = 1\n- { \"x\": 0, \"y\": 1, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 3, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 2, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 4, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 5, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 6, \"z\": 0}: mass = 1000, isFoundation = 0\n</code></pre>"},{"location":"tutorials/03-world-api/02-world-blocks/#delete-blocks","title":"Delete blocks","text":"<p>Again, any <code>world</code> modification goes through a <code>Transaction</code>. To remove blocks, just use <code>Transaction::removeBlock(BlockIndex)</code>:</p> <pre><code>{\n    auto tr = World::Transaction{};\n    tr.removeBlock({ 0,6,0 });\n    tr.removeBlock({ 0,5,0 });\n    world.modify(tr);\n}\n</code></pre> <p>This transaction will remove the 2 blocks at the top of the tower.</p> <p>Possible output of <code>printBlocks()</code>:</p> <pre><code>List of blocks (size = 5):\n- { \"x\": 0, \"y\": 0, \"z\": 0}: mass = 10000, isFoundation = 1\n- { \"x\": 0, \"y\": 1, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 3, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 2, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 4, \"z\": 0}: mass = 1000, isFoundation = 0\n</code></pre>"},{"location":"tutorials/03-world-api/02-world-blocks/#modify-blocks","title":"Modify blocks","text":"<p>To modify a block, remove &amp; add it in the same transaction:</p> <pre><code>{\n    auto tr = World::Transaction{};\n    tr.removeBlock({ 0,4,0 });\n    tr.addBlock({ {0,4,0}, maxBlockStress, heavyMass, false });\n    world.modify(tr);\n}\n</code></pre> <p>This transaction replaced the block at the top of the tower with a block of mass <code>heavyMass</code>.</p> <p>Possible output of <code>printBlocks()</code>:</p> <pre><code>List of blocks (size = 5):\n- { \"x\": 0, \"y\": 0, \"z\": 0}: mass = 10000, isFoundation = 1\n- { \"x\": 0, \"y\": 1, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 3, \"z\": 0}: mass = 1000, isFoundation = 0\n- { \"x\": 0, \"y\": 4, \"z\": 0}: mass = 10000, isFoundation = 0\n- { \"x\": 0, \"y\": 2, \"z\": 0}: mass = 1000, isFoundation = 0\n</code></pre>"},{"location":"tutorials/03-world-api/02-world-blocks/#inspect-a-block","title":"Inspect a block","text":"<p>There are two ways to get a <code>BlockReference</code> by index:</p> <ul> <li><code>world.blocks().at(BlockIndex)</code>: returns a <code>BlockReference</code> only if the block exists, throws otherwise.</li> <li><code>world.blocks().find(BlockIndex)</code>: always returns a <code>BlockReference</code> that must be tested for validity (<code>block.isValid()</code>) before use.</li> </ul> <p>The following example shows how to safely inspect a block using <code>find()</code>:</p> <pre><code>auto inspectBlock = [&amp;world](World::BlockIndex const&amp; blockId) -&gt; void {\n    std::cout &lt;&lt; \"Block at \" &lt;&lt; blockId &lt;&lt; \": \";\n    auto const blockRef = world.blocks().find(blockId);\n    if (blockRef.isValid()) {\n        std::cout &lt;&lt; \"mass = \" &lt;&lt; blockRef.mass() &lt;&lt; \", isFoundation = \" &lt;&lt; blockRef.isFoundation();\n    } else {\n        std::cout &lt;&lt; \"invalid\";\n    }\n    std::cout &lt;&lt; '\\n';\n};\ninspectBlock({ 0,0,0 });\ninspectBlock({ 0,1,0 });\ninspectBlock({ 9,9,9 });\n</code></pre> <p>Expected output:</p> <pre><code>Block at { \"x\": 0, \"y\": 0, \"z\": 0}: mass =  10000, isFoundation = 1\nBlock at { \"x\": 0, \"y\": 1, \"z\": 0}: mass =  1000, isFoundation = 0\nBlock at { \"x\": 9, \"y\": 9, \"z\": 9}: invalid\n</code></pre>"},{"location":"tutorials/03-world-api/03-world-structures/","title":"3.3. Structures","text":"<p>This sections explains how to inspect structures in a <code>SyncWorld</code>.</p> <p>Structures are automatically created/deleted by the <code>SyncWorld</code> when it is modified, so users can't directly edit structures. They can be inspected by getting a <code>StructureReference</code> object.</p>"},{"location":"tutorials/03-world-api/03-world-structures/#prerequisites","title":"Prerequisites","text":"<ul> <li>Selecting a Gustave configuration</li> <li>Creating an empty World: we'll reuse the <code>newWorld()</code> function.</li> </ul> <pre><code>auto world = newWorld();\n</code></pre> <ul> <li>Adding &amp; inspecting world blocks: we'll add a few blocks for this tutorial:</li> </ul> <pre><code>// kilogram\nauto const foundationMass = 10'0000.0;\nauto const struct1Mass = 1'000.0;\nauto const struct2Mass = 2'000.0;\nauto const struct3Mass = 3'000.0;\n{\n    auto tr = World::Transaction{};\n    // foundation shared between structure 1 &amp; 2\n    tr.addBlock({ { 0,0,0 }, maxBlockStress, foundationMass, true });\n    // structure 1\n    tr.addBlock({ { 0,1,0 }, maxBlockStress, struct1Mass, false });\n    tr.addBlock({ { 0,2,0 }, maxBlockStress, struct1Mass, false });\n    // structure 2\n    tr.addBlock({ { 1,0,0 }, maxBlockStress, struct2Mass, false });\n    tr.addBlock({ { 2,0,0 }, maxBlockStress, struct2Mass, false });\n    tr.addBlock({ { 3,0,0 }, maxBlockStress, struct2Mass, false });\n    tr.addBlock({ { 4,0,0 }, maxBlockStress, struct2Mass, true });\n    // structure 3 (no foundations)\n    tr.addBlock({ { 7,0,0 }, maxBlockStress, struct3Mass, false });\n    tr.addBlock({ { 8,0,0 }, maxBlockStress, struct3Mass, false });\n\n    world.modify(tr);\n}\n</code></pre> <p>Here's a visual representation of this world:</p> <p></p>"},{"location":"tutorials/03-world-api/03-world-structures/#list-all-structures-and-their-blocks","title":"List all structures and their blocks","text":"<p><code>world.structures()</code> is a forward range of <code>StructureReference</code>. You can iterate over it using a range-based for loop. Then a <code>StructureReference</code> has a <code>.blocks()</code> method, which works like <code>world.blocks()</code>, and is a range of <code>BlockReference</code> objects.</p> <p>So iterating over all structures and listing their blocks is a simple double loop:</p> <pre><code>std::cout &lt;&lt; \"List of structures (size = \" &lt;&lt; world.structures().size() &lt;&lt; \")\\n\";\nfor (auto const&amp; structure : world.structures()) {\n    std::cout &lt;&lt; \"- structure of \" &lt;&lt; structure.blocks().size() &lt;&lt; \" blocks:\\n\";\n    for (auto const&amp; block : structure.blocks()) {\n        std::cout &lt;&lt; \"  - \" &lt;&lt; block.index() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Note</p> <p>Both <code>world.structures()</code> and <code>structure.blocks()</code> are unordered containers, so all structures and blocks are given in no particular order.</p> <p>Possible output:</p> <pre><code>List of structures (size = 3)\n- structure of 2 blocks:\n  - { \"x\": 8, \"y\": 0, \"z\": 0}\n  - { \"x\": 7, \"y\": 0, \"z\": 0}\n- structure of 5 blocks:\n  - { \"x\": 4, \"y\": 0, \"z\": 0}\n  - { \"x\": 3, \"y\": 0, \"z\": 0}\n  - { \"x\": 2, \"y\": 0, \"z\": 0}\n  - { \"x\": 0, \"y\": 0, \"z\": 0}\n  - { \"x\": 1, \"y\": 0, \"z\": 0}\n- structure of 3 blocks:\n  - { \"x\": 0, \"y\": 2, \"z\": 0}\n  - { \"x\": 0, \"y\": 0, \"z\": 0}\n  - { \"x\": 0, \"y\": 1, \"z\": 0}\n</code></pre> <p>In the above output:</p> <ul> <li>The <code>2 blocks</code> structure is the blue one on the right.</li> <li>The <code>5 blocks</code> structure is the green one, and includes the 2 foundations</li> <li>The <code>3 blocks</code> structure is the red one on the left, and includes the bottom-left foundation.</li> </ul>"},{"location":"tutorials/03-world-api/03-world-structures/#list-all-structures-of-a-block","title":"List all structures of a block","text":"<p>A <code>BlockReference</code> has a <code>.structures()</code> method returning a range of <code>StructureReference</code>, similar to <code>world.structures()</code>:</p> <pre><code>auto listStructuresOfBlock = [&amp;world](World::BlockIndex const&amp; blockId) -&gt; void {\n    auto const blockRef = world.blocks().at(blockId);\n    std::cout &lt;&lt; \"Structures of block \" &lt;&lt; blockId &lt;&lt; \" (size = \" &lt;&lt; blockRef.structures().size() &lt;&lt; \"):\\n\";\n    for (auto const&amp; structureRef : blockRef.structures()) {\n        std::cout &lt;&lt; \"- structure of \" &lt;&lt; structureRef.blocks().size() &lt;&lt; \" blocks\\n\";\n    }\n};\nlistStructuresOfBlock({ 0,0,0 });\nlistStructuresOfBlock({ 7,0,0 });\n</code></pre> <p>Expected output:</p> <pre><code>Structures of block { \"x\": 0, \"y\": 0, \"z\": 0} (size = 2):\n- structure of 5 blocks\n- structure of 3 blocks\nStructures of block { \"x\": 7, \"y\": 0, \"z\": 0} (size = 1):\n- structure of 2 blocks\n</code></pre> <p>Note</p> <p>A non-foundation block always has exactly 1 structure. A foundation block can have 0 to 6 structures in a cuboid world.</p>"},{"location":"tutorials/03-world-api/03-world-structures/#structure-status-valid-and-solved","title":"Structure status: valid and solved","text":"<p>A <code>StructureReference</code> has two important methods about its status:</p> <ul> <li><code>isValid()</code>: checks if the structure still exists in the world. If <code>false</code>, all other operations on this reference will throw. This can happen if a <code>world.modify()</code> call deleted the structure.</li> <li><code>isSolved()</code>: checks if the solver was able to find a solution. It <code>false</code>, it is possible get the list of blocks, links and contacts of this structure, but reading forces and stresses will throw. This can happen if a structure has no foundation (or the solver didn't converge).</li> </ul> <p>Running this test code:</p> <pre><code>auto printStructureStatusOfBlock = [&amp;world](World::BlockIndex const&amp; blockId) -&gt; void {\n    auto const structureRef = world.blocks().at(blockId).structures()[0];\n    std::cout &lt;&lt; \"Statut of structure of block \" &lt;&lt; blockId &lt;&lt; \": \";\n    if (structureRef.isValid()) {\n        if (structureRef.isSolved()) {\n            std::cout &lt;&lt; \"solved\\n\";\n        } else {\n            std::cout &lt;&lt; \"not solved\\n\";\n        }\n    } else {\n        std::cout &lt;&lt; \"invalid\\n\";\n    }\n};\nprintStructureStatusOfBlock({ 0,1,0 });\nprintStructureStatusOfBlock({ 7,0,0 });\n</code></pre> <p>Should give the following output:</p> <pre><code>Statut of structure of block { \"x\": 0, \"y\": 1, \"z\": 0}: solved\nStatut of structure of block { \"x\": 7, \"y\": 0, \"z\": 0}: not solved\n</code></pre>"},{"location":"tutorials/03-world-api/04-world-links/","title":"3.4. Links, forces and stresses","text":"<p>This section explains how to inspect links and contacts in a <code>SyncWorld</code>.</p> <p>In a world, links and contacts have a force and a stress factor computed by the solver. They can be used to determine which blocks or structures are stable (or failing).</p> <p>As links and contacts are quite similar, they are both manipulated with the same type: <code>ContactReference</code>.</p>"},{"location":"tutorials/03-world-api/04-world-links/#prerequisites","title":"Prerequisites","text":"<ul> <li>Selecting a Gustave configuration</li> <li>Creating an empty World: we'll reuse the <code>newWorld()</code> function.</li> </ul> <pre><code>auto world = newWorld();\nauto world = newWorld();\n</code></pre> <ul> <li>Adding &amp; inspecting world blocks: we'll add a few blocks for this tutorial.</li> </ul> <p>We'll prepopulate the world:</p> <pre><code>// { compression, shear, tensile } in pascal\nauto const strongBlockStress = G::Model::PressureStress{ 500'000.0, 500'000.0, 500'000.0 };\nauto const weakBlockStress = G::Model::PressureStress{ 100'000.0, 100'000.0, 100'000.0 };\n// kilogram\nauto const mass = 3'000.0;\n\n{\n    auto tr = World::Transaction{};\n    // The chair\n    tr.addBlock({ { 0,8,0 }, weakBlockStress, mass, false });\n    tr.addBlock({ { 0,7,0 }, weakBlockStress, mass, false });\n    tr.addBlock({ { 0,6,0 }, weakBlockStress, mass, false });\n    tr.addBlock({ { 0,5,0 }, weakBlockStress, mass, false });\n    tr.addBlock({ { 0,4,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 0,3,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 0,2,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 0,1,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 0,0,0 }, strongBlockStress, mass, true });\n\n    tr.addBlock({ { 1,4,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 2,4,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 3,4,0 }, strongBlockStress, mass, false });\n\n    tr.addBlock({ { 4,4,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 4,3,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 4,2,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 4,1,0 }, strongBlockStress, mass, false });\n    tr.addBlock({ { 4,0,0 }, strongBlockStress, mass, true });\n\n    // Floating blocks\n    tr.addBlock({ { 3,8,0 }, weakBlockStress, mass, false });\n    tr.addBlock({ { 4,8,0 }, weakBlockStress, mass, false });\n\n    world.modify(tr);\n}\n</code></pre> <p>Which gives a chair and a floating platform:</p> <p></p> <p>Finally, a convenient alias to the <code>Direction</code> type, which holds an axis-aligned direction (plusX, minusX, plusY, ...):</p> <pre><code>using Direction = World::ContactIndex::Direction;\n</code></pre>"},{"location":"tutorials/03-world-api/04-world-links/#inspect-a-specific-contact","title":"Inspect a specific contact","text":"<p>To get a specific <code>ContactReference</code>, use the method <code>world.contacts().at(...)</code>. The parameter is a <code>ContactIndex</code>, made of:</p> <ul> <li>the <code>BlockIndex</code> of the block owning the contact surface.</li> <li>a <code>Direction</code>, getting a single surface of this block.</li> </ul> <pre><code>{\n    auto const contact = world.contacts().at({ {0,4,0}, Direction::plusY() });\n    std::cout &lt;&lt; \"Contact \" &lt;&lt; contact.index() &lt;&lt; \": other block is \" &lt;&lt; contact.otherBlock().index() &lt;&lt; '\\n';\n}\n</code></pre> <p>Expected output:</p> <pre><code>Contact { \"blockIndex\": { \"x\": 0, \"y\": 4, \"z\": 0}, \"direction\": \"plusY\" }: other block is { \"x\": 0, \"y\": 5, \"z\": 0}\n</code></pre>"},{"location":"tutorials/03-world-api/04-world-links/#check-a-contacts-status","title":"Check a contact's status","text":"<p>Like structures, a <code>ContactReference</code> has 2 important methods to check its status.</p> <ul> <li><code>isValid()</code> checks if the contact exists. If false, almost all other operations on this reference will throw.</li> <li><code>isSolved()</code> checks if the solver was able to find a force distribution for the structure owning this contact. If false, some operations will throw (reading force, pressure or stress). It implies <code>isValid()</code>.</li> </ul> <pre><code>{\n    auto printContactStatus = [&amp;world](World::ContactIndex const&amp; contactId) -&gt; void {\n        auto const contactRef = world.contacts().find(contactId);\n        std::cout &lt;&lt; \"Contact \" &lt;&lt; contactId &lt;&lt; \": \";\n        if (contactRef.isValid()) {\n            if (contactRef.isSolved()) {\n                std::cout &lt;&lt; \"solved\\n\";\n            } else {\n                std::cout &lt;&lt; \"unsolved\\n\";\n            }\n        } else {\n            std::cout &lt;&lt; \"invalid\\n\";\n        }\n    };\n    printContactStatus({ {0,4,0}, Direction::plusY() });\n    printContactStatus({ {3,8,0}, Direction::plusX() });\n    printContactStatus({ {9,9,0}, Direction::minusX() });\n}\n</code></pre> <p>Expected output:</p> <pre><code>Contact { \"blockIndex\": { \"x\": 0, \"y\": 4, \"z\": 0}, \"direction\": \"plusY\" }: solved\nContact { \"blockIndex\": { \"x\": 3, \"y\": 8, \"z\": 0}, \"direction\": \"plusX\" }: unsolved\nContact { \"blockIndex\": { \"x\": 9, \"y\": 9, \"z\": 0}, \"direction\": \"minusX\" }: invalid\n</code></pre>"},{"location":"tutorials/03-world-api/04-world-links/#contacts-force","title":"Contact's force","text":"<p>For a solved <code>ContactReference</code>, the <code>forceVector()</code> method is available. It returns the force exerced by <code>otherBlock()</code> on <code>localBlock()</code> through this link:</p> <pre><code>{\n    auto printContactForce = [&amp;world](World::ContactIndex const&amp; contactId) -&gt; void {\n        auto const cRef = world.contacts().at(contactId);\n        std::cout &lt;&lt; \"Force vector by block \" &lt;&lt; cRef.otherBlock().index() &lt;&lt; \" on block \" &lt;&lt; cRef.localBlock().index();\n        std::cout &lt;&lt; \" = \" &lt;&lt; cRef.forceVector() &lt;&lt; '\\n';\n    };\n    printContactForce({ {0,4,0}, Direction::plusY() });\n    printContactForce({ {0,1,0}, Direction::minusY() });\n    printContactForce({ {4,1,0}, Direction::minusY() });\n}\n</code></pre> <p>Possible output:</p> <pre><code>Force vector by block { \"x\": 0, \"y\": 5, \"z\": 0} on block { \"x\": 0, \"y\": 4, \"z\": 0} = { \"x\": 0, \"y\": -120000, \"z\": 0 }\nForce vector by block { \"x\": 0, \"y\": 0, \"z\": 0} on block { \"x\": 0, \"y\": 1, \"z\": 0} = { \"x\": -0, \"y\": 244591, \"z\": -0 }\nForce vector by block { \"x\": 4, \"y\": 0, \"z\": 0} on block { \"x\": 4, \"y\": 1, \"z\": 0} = { \"x\": -0, \"y\": 205409, \"z\": -0 }\n</code></pre> <p>A few comment on this output:</p> <ul> <li>Line 1: According to Newton's first law of motion, this contact must receive the full weight of the 4 blocks making the \"back of the chair\". The weight vector of 4 blocks is <code>4 * mass * g = {0, -120'000, 0} Newton</code>.</li> <li>Line 2 &amp; 3: These 2 contacts are on the surface of the 2 foundations blocks supporting the whole chair. How Gustave balance the weight between the 2 feet is implementation defined, but the sum of these two forces must be the opposite  of the weight vector of the chair. Chair's weight vector: <code>15 * mass * g = {0, -450'000, 0} Newton</code></li> </ul> <p>Note</p> <p>The solver doesn't always find an exact solution (regarding Newton's first law). Remember the <code>solverPrecision</code> value from Tutorial: Configure a solver ? This is where it matters: here the solver is allowed a <code>0.01</code> (1%) error factor. So the Y-value in line 1 could be between <code>-118'800</code> and <code>-121'200</code> Newton.</p>"},{"location":"tutorials/03-world-api/04-world-links/#links-stress-ratio","title":"Link's stress ratio","text":"<p>This is the ratio <code>actual_pressure / max_nominal_pressure</code>, expressed as compression/shear/tensile components. This is an important property to check the link's stability: if all components are below 1, the link is stable. Otherwise, the link is failing.</p> <p>A solved <code>ContactReference</code> has a <code>stressRatio()</code> method:</p> <pre><code>{\n    auto printContactStress = [&amp;world](World::ContactIndex const&amp; contactId) -&gt; void {\n        auto const cRef = world.contacts().at(contactId);\n        std::cout &lt;&lt; \"Stress of link \" &lt;&lt; contactId &lt;&lt; \" = \" &lt;&lt; cRef.stressRatio() &lt;&lt; '\\n';\n    };\n    printContactStress({ {0,4,0}, Direction::plusY() });\n    printContactStress({ {0,1,0}, Direction::minusY() });\n    printContactStress({ {4,1,0}, Direction::minusY() });\n}\n</code></pre> <p>Possible output:</p> <pre><code>Stress of link { \"blockIndex\": { \"x\": 0, \"y\": 4, \"z\": 0}, \"direction\": \"plusY\" } = { \"compression\": 1.2, \"shear\": 0, \"tensile\": 0 }\nStress of link { \"blockIndex\": { \"x\": 0, \"y\": 1, \"z\": 0}, \"direction\": \"minusY\" } = { \"compression\": 0.489183, \"shear\": 0, \"tensile\": 0 }\nStress of link { \"blockIndex\": { \"x\": 4, \"y\": 1, \"z\": 0}, \"direction\": \"minusY\" } = { \"compression\": 0.410817, \"shear\": 0, \"tensile\": 0 }\n</code></pre> <p>So here the 2 feet of the chair are stable, but the link at the base of chair's back is failing.</p>"},{"location":"tutorials/03-world-api/04-world-links/#stress-ratio-of-a-structure","title":"Stress ratio of a structure","text":"<p>As a conclusion to the <code>SyncWorld</code> tutorial, here is how to safely test the stress ratio of a structure (and therefore its stability):</p> <pre><code>{\n    auto printMaxStressOfStructure = [&amp;world](World::BlockIndex const&amp; blockId) -&gt; void {\n        // Gets the StructureReference of a block (unique for a non-foundation).\n        auto const structRef = world.blocks().at(blockId).structures()[0];\n        std::cout &lt;&lt; \"Max stress ratio of structure of block \" &lt;&lt; blockId &lt;&lt; \" = \";\n        // Ensures that we can access forces &amp; stresses of all links in the structure.\n        if (structRef.isSolved()) {\n            auto result = G::Model::StressRatio{ 0.0, 0.0, 0.0 };\n            // Iterate over all links of the structure.\n            for (auto const&amp; linkRef : structRef.links()) {\n                result.mergeMax(linkRef.stressRatio());\n            }\n            std::cout &lt;&lt; result &lt;&lt; '\\n';\n        } else {\n            std::cout &lt;&lt; \"unsolved structure\\n\";\n        }\n    };\n    printMaxStressOfStructure({ 0,1,0 });\n    printMaxStressOfStructure({ 3,8,0 });\n}\n</code></pre> <p>Possible output:</p> <pre><code>Max stress ratio of structure of block { \"x\": 0, \"y\": 1, \"z\": 0} = { \"compression\": 1.2, \"shear\": 0.169471, \"tensile\": 0 }\nMax stress ratio of structure of block { \"x\": 3, \"y\": 8, \"z\": 0} = unsolved structure\n</code></pre> <ul> <li>Line 1 tells us that the chair is failing due to compression constraints. It is also subjected to some shear constraints that don't cause any failure.</li> <li>Line 2 tells us that the magically floating platform has no solution.</li> </ul> <p>This function is easily adaptable to:</p> <ul> <li>Get the block with the highest stress ratio (the most likely to break).</li> <li>Get a list of blocks with any stress component above 1 (= the list of failing blocks).</li> </ul>"}]}